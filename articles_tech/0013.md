# React 笔记


**List**

* 关于 Hooks
* useCallback & useMemo
* useReducer
* ProvidersComposer
* 遗留问题合集



## 关于 Hooks

开发过程中注意配合插件 eslint-plugin-react-hooks，指定相关规则 rules-of-hooks、exhaustive-deps


## Why there is no callback for setState, useEffect

Because it invokes a thought pattern that may very well be an antipattern with hooks.

With hooks, you are writing code more declarative than imparative.

The thought of "do one thing THEN do another thing THEN do another thing" would be the imparative (here: callback- or promise-based) way.

What actually should be done in the hooks model would rather be a "if this has been rendered, and this property is different than before, X should be done to reach the target state", which is more declarative. You don't designate when stuff happens, but just give a condition/dependency and let react pick the right point in time for it.


## useCallback & useMemo

useCallback(fn, deps) 相当于 useMemo(() => fn, deps)

useCallback(fn, deps) 返回 fn 这个会根据 deps 变化的回调函数，侧重于函数

而 useMemo(() => fn/computeExpensiveValue(a, b), [a, b]) 侧重于返回值，哪怕你这个返回值实际上是个函数


## useReducer

```jsx
function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  function dispatch(action) {
    const nextState = reducer(state, action);
    setState(nextState);
  }

  return [state, dispatch];
}
```

## ProvidersComposer

```jsx
const ProviderComposer = ({ providers, children }) => {
  return providers.reduceRight((children, parent, index) => React.cloneElement(parent, { children }), children);
};

const ProvidersComposer = (props: any) => {
  return (
    props.providers.reduceRight((children: any, Parent: any) => (
      <Parent>{ children }</Parent>
    ), props.children)
  );
};
```

## 遗留问题合集

* 为什么会渲染两次


### 为什么会渲染两次

```jsx
class Test extends Components {
  render() {
    console.log('render');
    return <div>Test</div>;
  }
}
```

上面这个说实话我讲不出所以然，改用现在函数式的写法不会渲染两次，再看下面这个：


```jsx
const Test = () => {
  const [f, setF] = useState(false);
  let t = useRef(null);

  const onClick = () => {
    setF(true);
  };

  console.log('render: ', f);

  return (
    <div style={{ width: '200px', height: '100px', backgroundColor: '#3fa' }} onClick={onClick} ref={t}>
      {f.toString()}
    </div>
  );
};
```

这个的第一次点击，将状态 f 从 false 变更成 true，这个 render 还能理解，可以再点击一次，还会打印，之后继续点击，再无反应，这个怎么解释呢？